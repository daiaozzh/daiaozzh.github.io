<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>java面试题整理（一）</title>
      <link href="/2020/03/18/javamianshi1/"/>
      <url>/2020/03/18/javamianshi1/</url>
      
        <content type="html"><![CDATA[<h2 id="JAVA-面试题整理（一）"><a href="#JAVA-面试题整理（一）" class="headerlink" title="JAVA 面试题整理（一）"></a>JAVA 面试题整理（一）</h2><p><img src="https://ss0.bdstatic.com/94oJfD_bAAcT8t7mm9GUKT-xh_/timg?image&quality=100&size=b4000_4000&sec=1584521624&di=c6113eac35cace66d3746306e81719a6&src=http://www.hfxms.com.cn/UploadFiles/2018-07-23/15323296433591367.jpg" alt="img"></p><p>整理一些常见面试题</p><p>1.short s1=1,s1=s1+1;有错误吗？short s1=1;s1+=1,有错误吗？</p><p>答：（1）错误，对于short s1=1,s1=s1+1,由于1是int类型，所以s1+1的运算结果也是int类型，需要强制转换类型才能赋值给short型。（2）正确，对于short s1=1;s1+=1;s1+=1相当于 s1=(short)(s1+1);其中包括了强制类型转换，所以可以编译 成功</p><p>2.java有没有goto</p><p>答：有保留关键字，但是用较少</p><p>3.int和integer的区别</p><p>答：int是基本数据类型，Integer是包装数据类型；拓展：Java为每一个原始类型提供了包装数据类型；（自动拆箱自动装箱）</p><p>-原始数据类型：int,boolean,char,byte,short,double,float,long</p><p>-包装数据类型：Boolean,Character,Byte,Short,Integer,Long,Float,Double</p><p>4.&amp;和&amp;&amp;的区别</p><p>答：&amp;是位运算，&amp;&amp;是逻辑 与</p><p>5.解释内存中的栈（Stack）、堆（heap）、和静态区（static area）的用法</p><p>答：栈 new 一个值，堆 定义一个值 静态区内存</p><p>6.Math.round(11.5)等于多少？Math.round(-11.5)等于多少？</p><p>答：12和-11，四舍五入的原理就是在参上加上0.5然后进行向下取整。</p><p>7.swtich是否作用在byte上，是否作用在long上，是否作用在String上？</p><p>答：long,byte不支持，string支持</p><p>8.用最有效率的方法计算2乘以8？</p><p>答：2&lt;&lt;3（左移三位表示乘以的2的3次方右移则表示除以2的3次方）</p><p>9.数组有没有length（）方法？String有没有length()方法？</p><p>答：数组没有length()方法但是有这个属性，String有这个方法</p><p>10.在java中，如何跳出当前的多重嵌套循环</p><p>答：break;</p><p>11.构造器（constructor）是否可以被重写（override）</p><p>答：不可以，构造器不能被继承，因此不能被重写，但可以重载</p><p>12.两个对象值相同（x.equals(y)==true）,但却有不同的  hash code，这句话对不对？</p><p>答：不对，当两个对象满足x.equals(y)==true，它们的哈希码应该是相同的；</p><p>13.是否可以继承String类？</p><p>答：String是final类，不可以被继承。</p><p>14.String和StringBulider,StringBuffer的区别？</p><p>答：JAVA平台提供两种类型的字符串，String和StringBulider、StringBuffer，它们都能储存、操作字符串，其中String只是只读字符串意味着不能被修改，而另外两个可以被修改</p><p>15.重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</p><p>答：（1）方法重载和重写都是实现多态的方式，区别在于重载是在编译时实现多态，重写是运行时候实现多态；（2）重写要求要求子类被重写方法与父类被重写方法有相同的返回类型，重载看参数类型和个数，不看返回类型；</p><p>16.char型变量中能不能储存一个中文汉字，为什么？</p><p>答：可以储存，char类型占2个字节，所以存放一个中文汉字没问题；</p><p>17.抽象类（abstract class）和接口（interface）有什么异同？</p><p>答:（1）抽象类和接口都不能够实例化，但可以定义抽象类和接口类型的引用。（2）声明方法不同（3）字段属性访问权限不同，抽象类可以是各种访问，接口默认是public,static finalI;(4)</p><p>18.静态嵌套类和内部类的不同？</p><p>答：静态类不需要外部堆其进行实例化，内部类必须要外部对其实例化才能实例化</p><p>19.GC是什么为什么要有GC？</p><p>答：垃圾回收机制，防止系统崩溃，提高效率</p><p>20.接口是否可以继承（extends）接口？抽象类是否可以实现（implements）接口？抽象类是否可以继承具体类（concrete class）?</p><p>答：接口可以继承接口，而且支持多重继承。抽象类可以实现接口，抽象类可继承具体类也可以继承抽象类。</p><p>21.java中的final关键字有哪些用法？</p><p>答：修饰类：表示该类不能被继承，修饰方法：表示方法不能被重写。修饰变量：表示变量是常量</p><p>22.Java语音如何进行异常处理，关键字：throws,throw,try,catch,finally分别如何使用？</p><p>答：Java通过面向对象的方法进行异常处理，把不同的异常进行分类，并且提供了良好的接口。</p><p>try:用来指定一块预防所有异常的程序；</p><p>Throws：语句用来明确的抛出一个异常；</p><p>catch:紧跟try块后面，用来指定你想要捕获的异常的类型</p><p>Finally：为确保一段代码不管发生什么异常状况都要被执行</p><p>23（*）.列一些你常见的运行时的异常？</p><p>答：算数异常，类转换异常。非法参数异常，下标越界异常，空指针异常。安全异常；</p><p>24（*）.阐述final，finaly,finalize的区别</p><p>答：final修饰符，有三种修饰用法，finaly通常放在try…catch后面，处理异常用法，finalize是obeject中的方法，在垃圾回收对象钱要调用此方法进行操作；</p><p>25.list,Set,Map是否继承自Conllection接口？</p><p>答:list,set是的，Map不是；</p><p>26（*）阐述ArryList,Vector,LinkenList的储存性能和特性。</p><p>答：ArryList、Vector的底层是数组，Vector线程安全效率低下。LinkenList基于表链，相比ArryList增删块，查询慢；</p><p>27.（*）Collection和Collections的区别？</p><p>答：Collection是一个接口，它是Set,list等容器的父接口；Conllections是工具类，提供一系列的静态方法来辅助容器操作</p><p>28.List,Map,Set三个接口存取元素时，各有什么特点？</p><p>答：list能存放重复元素，Map保存键值对映射，映射关系科颜氏一对多或者是一对一，set不能存放相同元素；</p><p>29.编写多线程程序有几种实现方法？</p><p>答：一种是继承Thread类，另一中是实现Runnable接口</p><p>30.Java中有几种类型的流</p><p>答：字符流和字节流</p><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>今日暂时学习了解这些面试题目</p><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=2541258383,2247312097&fm=26&gp=0.jpg" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 分享 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2020/03/17/docker/"/>
      <url>/2020/03/17/docker/</url>
      
        <content type="html"><![CDATA[<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584460087078&di=993352b74157410f902bb46e43cf6505&imgtype=0&src=http%3A%2F%2Fpic1.zhimg.com%2Fv2-db080a21341c9aa0a7d508e39353531f_1200x500.jpg" alt="img"></p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Docker 是一个开源的应用容器引擎，基于 <a href="https://www.runoob.com/go/go-tutorial.html" target="_blank" rel="noopener">Go 语言</a> 并遵从 Apache2.0 协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p><h3 id="Docker的应用场景"><a href="#Docker的应用场景" class="headerlink" title="Docker的应用场景"></a>Docker的应用场景</h3><ul><li><p>Web 应用的自动化打包和发布。</p></li><li><p>自动化测试和持续集成、发布。</p></li><li><p>在服务型环境中部署和调整数据库或其他的后台应用。</p></li><li><p>从头编译或者扩展现有的 OpenShift 或 Cloud Foundry 平台来搭建自己的 PaaS 环境。</p></li></ul><h3 id="Docker-的优点"><a href="#Docker-的优点" class="headerlink" title="Docker 的优点"></a>Docker 的优点</h3><p>Docker 是一个用于开发，交付和运行应用程序的开放平台。Docker 使您能够将应用程序与基础架构分开，从而可以快速交付软件。借助 Docker，您可以与管理应用程序相同的方式来管理基础架构。通过利用 Docker 的方法来快速交付，测试和部署代码，您可以大大减少编写代码和在生产环境中运行代码之间的延迟。</p><h4 id="1、快速，一致地交付您的应用程序"><a href="#1、快速，一致地交付您的应用程序" class="headerlink" title="1、快速，一致地交付您的应用程序"></a>1、快速，一致地交付您的应用程序</h4><p>Docker 允许开发人员使用您提供的应用程序或服务的本地容器在标准化环境中工作，从而简化了开发的生命周期。</p><p>容器非常适合持续集成和持续交付（CI / CD）工作流程，请考虑以下示例方案：</p><ul><li>您的开发人员在本地编写代码，并使用 Docker 容器与同事共享他们的工作。</li><li>他们使用 Docker 将其应用程序推送到测试环境中，并执行自动或手动测试。</li><li>当开发人员发现错误时，他们可以在开发环境中对其进行修复，然后将其重新部署到测试环境中，以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境，就像将更新的镜像推送到生产环境一样简单。</li></ul><h4 id="2、响应式部署和扩展"><a href="#2、响应式部署和扩展" class="headerlink" title="2、响应式部署和扩展"></a>2、响应式部署和扩展</h4><p>Docker 是基于容器的平台，允许高度可移植的工作负载。Docker 容器可以在开发人员的本机上，数据中心的物理或虚拟机上，云服务上或混合环境中运行。</p><p>Docker 的可移植性和轻量级的特性，还可以使您轻松地完成动态管理的工作负担，并根据业务需求指示，实时扩展或拆除应用程序和服务。</p><h4 id="3、在同一硬件上运行更多工作负载"><a href="#3、在同一硬件上运行更多工作负载" class="headerlink" title="3、在同一硬件上运行更多工作负载"></a>3、在同一硬件上运行更多工作负载</h4><p>Docker 轻巧快速。它为基于虚拟机管理程序的虚拟机提供了可行、经济、高效的替代方案，因此您可以利用更多的计算能力来实现业务目标。Docker 非常适合于高密度环境以及中小型部署，而您可以用更少的资源做更多的事情。</p><h2 id="安装及其使用"><a href="#安装及其使用" class="headerlink" title="安装及其使用"></a>安装及其使用</h2><h3 id="CentOs-7"><a href="#CentOs-7" class="headerlink" title="CentOs 7"></a>CentOs 7</h3><p><strong>1.检查内核版本，返回的值大于3.10即可。</strong></p><p> $ uname -r</p><p><img src="https://img-blog.csdn.net/20170629163943864?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4OTIzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><strong>2.使用 sudo 或 root 权限的用户登入终端。</strong></p><p><strong>3.确保yum是最新的</strong></p><p> $ yum update</p><p><strong>4.添加 yum 仓库</strong></p><pre><code class="java">tee /etc/yum.repos.d/docker.repo &lt;&lt;-&#39;EOF&#39;[dockerrepo]name=Docker Repositorybaseurl=https://yum.dockerproject.org/repo/main/centos/$releasever/enabled=1gpgcheck=1gpgkey=https://yum.dockerproject.org/gpgEOF</code></pre><p><img src="https://img-blog.csdn.net/20170629164910967?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4OTIzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><strong>5.安装 Docker</strong></p><p> $ yum install -y docker-engine</p><p>安装成功后，使用docker version命令查看是否安装成功，安装成功后——如下图</p><p><img src="https://img-blog.csdn.net/20170629165725357?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4OTIzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><strong>6.启动docker</strong></p><p>$systemctl start docker.service</p><p><strong>7.验证安装是否成功(有client和service两部分表示docker安装启动都成功了)</strong></p><p><strong>使用docker version命令查看</strong></p><p><img src="https://img-blog.csdn.net/20170629170029388?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcXFfMzY4OTIzNDE=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img"></p><p><strong>8.设置开机自启动</strong></p><p> $ sudo systemctl enable docker</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>个人博客2.0</title>
      <link href="/2020/03/17/hellword/"/>
      <url>/2020/03/17/hellword/</url>
      
        <content type="html"><![CDATA[<h2 id="个人博客2-0"><a href="#个人博客2-0" class="headerlink" title="个人博客2.0"></a>个人博客2.0</h2><p><img src="https://timgsa.baidu.com/timg?image&quality=80&size=b9999_10000&sec=1584455651935&di=90bb9c853d36d675dd45b903513ce1ab&imgtype=0&src=http%3A%2F%2Fwx4.sinaimg.cn%2Flarge%2F006m97Kgly1fvo77ncb2pj311s0qojuj.jpg" alt="img"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>前几天写个人简历的时候准备写一下自己的项目经验，发现自己项目少的可怜，看到了自己以前的个人博客，说实话以前那博客刚写的时候感觉还可以，看久了感觉十分的low，前几天由于数据库的丢失使我不得不重新再搞一个☝️博客，所以才有了这个博客；顺便附上老版本的博客地址：<a href="http://49.235.232.45" target="_blank" rel="noopener">博客</a>；</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>偶然了解到个人博客有一个Hexo框架，所以特地去了解了一下，步骤基本上很简单，总结一下：</p><ol><li><p>安装Git Bash</p></li><li><p>安装NodeJs</p></li><li><p>安装hexo</p></li><li><p>生成SSH并添加到github</p></li><li><p>部署项目</p></li><li><p>上传到github</p></li><li><p>绑定个人域名</p></li><li><p>修改及配置主题</p></li></ol><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>以后的遇见的问题解决之后，记录下来，把自己学的东西记录下来，及时整理；</p>]]></content>
      
      
      <categories>
          
          <category> 开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
